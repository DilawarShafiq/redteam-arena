"""
GitHub PR commenter â€” posts battle findings as PR comments.
Uses httpx for async HTTP requests to GitHub REST API.
"""

from __future__ import annotations

import os

from redteam_arena.types import Battle

SEVERITY_EMOJI: dict[str, str] = {
    "critical": "!!",
    "high": "!",
    "medium": "~",
    "low": "-",
}


def build_pr_comment(battle: Battle) -> str:
    """Build a Markdown PR comment from a battle result."""
    all_findings = [f for r in battle.rounds for f in r.findings]
    all_mitigations = [m for r in battle.rounds for m in r.mitigations]

    by_severity: dict[str, int] = {"critical": 0, "high": 0, "medium": 0, "low": 0}
    for f in all_findings:
        by_severity[f.severity] += 1

    coverage = (
        round((len(all_mitigations) / len(all_findings)) * 100)
        if all_findings
        else 100
    )

    lines: list[str] = []

    lines.append("## RedTeam Arena -- Battle Report")
    lines.append("")
    lines.append(
        f"**Scenario:** {battle.config.scenario.name} | "
        f"**Rounds:** {len(battle.rounds)} | "
        f"**Status:** {battle.status}"
    )
    lines.append("")

    if not all_findings:
        lines.append(
            "**No vulnerabilities found.** Your code passed the adversarial security test."
        )
        lines.append("")
    else:
        lines.append("| Severity | Count |")
        lines.append("|----------|-------|")
        if by_severity["critical"] > 0:
            lines.append(f"| {SEVERITY_EMOJI['critical']} Critical | **{by_severity['critical']}** |")
        if by_severity["high"] > 0:
            lines.append(f"| {SEVERITY_EMOJI['high']} High | **{by_severity['high']}** |")
        if by_severity["medium"] > 0:
            lines.append(f"| {SEVERITY_EMOJI['medium']} Medium | **{by_severity['medium']}** |")
        if by_severity["low"] > 0:
            lines.append(f"| {SEVERITY_EMOJI['low']} Low | {by_severity['low']} |")
        lines.append(f"| **Total** | **{len(all_findings)}** |")
        lines.append("")
        lines.append(f"**Mitigations:** {len(all_mitigations)}/{len(all_findings)} ({coverage}%)")
        lines.append("")

        # Top findings (max 10)
        lines.append("<details>")
        lines.append("<summary>Top Findings (click to expand)</summary>")
        lines.append("")

        for finding in all_findings[:10]:
            mitigation = next(
                (m for m in all_mitigations if m.finding_id == finding.id), None
            )
            lines.append(
                f"### {SEVERITY_EMOJI[finding.severity]} "
                f"`{finding.file_path}:{finding.line_reference}`"
            )
            lines.append("")
            lines.append(f"**{finding.severity.upper()}** -- {finding.description}")
            lines.append("")
            if finding.code_snippet:
                lines.append("```")
                lines.append(finding.code_snippet)
                lines.append("```")
                lines.append("")
            if mitigation:
                lines.append(
                    f"> **Fix ({mitigation.confidence} confidence):** {mitigation.proposed_fix}"
                )
                lines.append("")

        if len(all_findings) > 10:
            lines.append(
                f"*...and {len(all_findings) - 10} more findings. See full report for details.*"
            )
            lines.append("")

        lines.append("</details>")
        lines.append("")

    lines.append("---")
    lines.append(
        "*Generated by [RedTeam Arena](https://github.com/DilawarShafiq/redteam-arena) "
        "-- AI vs AI adversarial security testing*"
    )

    return "\n".join(lines)


async def post_pr_comment(
    battle: Battle,
    *,
    token: str = "",
    owner: str = "",
    repo: str = "",
    pr_number: int = 0,
) -> None:
    """Post battle results as a PR comment on GitHub."""
    try:
        import httpx
    except ImportError as exc:
        raise ImportError(
            "httpx required for PR comments. Install with: pip install httpx"
        ) from exc

    resolved_token = token or os.environ.get("GITHUB_TOKEN", "")
    if not resolved_token:
        raise ValueError("GITHUB_TOKEN environment variable required for PR comments")

    # Auto-detect owner/repo from GITHUB_REPOSITORY
    if not owner or not repo:
        gh_repo = os.environ.get("GITHUB_REPOSITORY", "")
        if "/" in gh_repo:
            owner, repo = gh_repo.split("/", 1)

    if not pr_number:
        # Try to extract from GITHUB_REF (refs/pull/123/merge)
        gh_ref = os.environ.get("GITHUB_REF", "")
        if "/pull/" in gh_ref:
            try:
                pr_number = int(gh_ref.split("/pull/")[1].split("/")[0])
            except (ValueError, IndexError):
                pass

    if not owner or not repo or not pr_number:
        raise ValueError("Cannot determine PR details. Set GITHUB_REPOSITORY and GITHUB_REF.")

    body = build_pr_comment(battle)
    marker = "<!-- redteam-arena-comment -->"
    full_body = f"{marker}\n{body}"

    base_url = f"https://api.github.com/repos/{owner}/{repo}"
    headers = {
        "Authorization": f"Bearer {resolved_token}",
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
    }

    async with httpx.AsyncClient() as client:
        # Check for existing comment to update
        resp = await client.get(
            f"{base_url}/issues/{pr_number}/comments",
            headers=headers,
            params={"per_page": 100},
        )

        if resp.status_code == 200:
            comments = resp.json()
            existing = next(
                (c for c in comments if c.get("body", "").startswith(marker)),
                None,
            )

            if existing:
                await client.patch(
                    f"{base_url}/issues/comments/{existing['id']}",
                    headers=headers,
                    json={"body": full_body},
                )
                return

        # Create new comment
        await client.post(
            f"{base_url}/issues/{pr_number}/comments",
            headers=headers,
            json={"body": full_body},
        )
