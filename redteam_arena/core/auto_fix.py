"""
Auto-fix mode -- applies Blue Agent mitigations directly.
Creates git branches per fix, generates commit messages.
Human review required -- never auto-merges.
"""

from __future__ import annotations

import asyncio
import os
from dataclasses import dataclass, field

from redteam_arena.types import Battle, Err, Finding, Mitigation, Ok, Result


@dataclass
class FixResult:
    finding_id: str
    file_path: str
    description: str
    branch: str = ""
    applied: bool = False
    reason: str = ""


@dataclass
class AutoFixSummary:
    total_findings: int
    fixable_findings: int
    applied_fixes: int
    skipped_fixes: int
    fixes: list[FixResult] = field(default_factory=list)


def _get_fixable_pairs(
    battle: Battle,
) -> list[tuple[Finding, Mitigation]]:
    """Pair findings with high/medium-confidence mitigations."""
    all_findings = [f for r in battle.rounds for f in r.findings]
    all_mitigations = [m for r in battle.rounds for m in r.mitigations]

    pairs: list[tuple[Finding, Mitigation]] = []
    for finding in all_findings:
        mitigation = next(
            (
                m
                for m in all_mitigations
                if m.finding_id == finding.id
                and m.confidence in ("high", "medium")
            ),
            None,
        )
        if mitigation:
            pairs.append((finding, mitigation))

    # Sort by severity: critical first
    order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
    pairs.sort(key=lambda p: order.get(p[0].severity, 4))

    return pairs


def _sanitize_branch_name(name: str) -> str:
    """Sanitize a string for use in a git branch name."""
    result = name.lower()
    clean = ""
    for ch in result:
        if ch.isalnum() or ch == "-":
            clean += ch
        else:
            clean += "-"
    # Collapse multiple dashes
    while "--" in clean:
        clean = clean.replace("--", "-")
    clean = clean.strip("-")
    return clean[:40]


def _generate_fix_description(finding: Finding, mitigation: Mitigation) -> str:
    """Generate a fix description file content."""
    lines: list[str] = []
    lines.append(f"# Auto-Fix: {finding.description[:80]}")
    lines.append("")
    lines.append(f"**Severity:** {finding.severity.upper()}")
    lines.append(f"**File:** `{finding.file_path}:{finding.line_reference}`")
    lines.append(f"**Finding ID:** {finding.id}")
    lines.append("")
    lines.append("## Vulnerability")
    lines.append("")
    lines.append(finding.description)
    lines.append("")
    lines.append(f"**Attack Vector:** {finding.attack_vector}")
    lines.append("")
    if finding.code_snippet:
        lines.append("**Vulnerable Code:**")
        lines.append("```")
        lines.append(finding.code_snippet)
        lines.append("```")
        lines.append("")
    lines.append("## Proposed Fix")
    lines.append("")
    lines.append(f"**Confidence:** {mitigation.confidence.upper()}")
    lines.append("")
    lines.append(f"> {mitigation.acknowledgment}")
    lines.append("")
    lines.append(mitigation.proposed_fix)
    lines.append("")
    lines.append("---")
    lines.append("*Generated by RedTeam Arena auto-fix mode. Human review required.*")
    return "\n".join(lines)


async def _run_git(target_dir: str, *args: str) -> tuple[int, str, str]:
    """Run a git command and return (returncode, stdout, stderr)."""
    proc = await asyncio.create_subprocess_exec(
        "git", *args,
        cwd=target_dir,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await proc.communicate()
    return (
        proc.returncode or 0,
        stdout.decode("utf-8", errors="replace").strip(),
        stderr.decode("utf-8", errors="replace").strip(),
    )


async def _is_git_clean(target_dir: str) -> bool:
    code, stdout, _ = await _run_git(target_dir, "status", "--porcelain")
    return code == 0 and len(stdout) == 0


async def _get_current_branch(target_dir: str) -> str:
    code, stdout, _ = await _run_git(target_dir, "rev-parse", "--abbrev-ref", "HEAD")
    return stdout if code == 0 else "main"


async def run_auto_fix(
    target_dir: str,
    battle: Battle,
    *,
    create_branch: bool = True,
    dry_run: bool = False,
) -> Result[AutoFixSummary, Exception]:
    """Run auto-fix analysis and generate fix branches."""
    all_findings = [f for r in battle.rounds for f in r.findings]
    fixable_pairs = _get_fixable_pairs(battle)
    fixes: list[FixResult] = []

    if create_branch and not dry_run:
        if not await _is_git_clean(target_dir):
            return Err(
                error=Exception(
                    "Working directory has uncommitted changes. "
                    "Commit or stash before auto-fix."
                )
            )

    base_branch = await _get_current_branch(target_dir)

    for finding, mitigation in fixable_pairs:
        branch_name = (
            f"fix/redteam-{finding.id}-"
            f"{_sanitize_branch_name(finding.description)}"
        )

        if dry_run:
            fixes.append(
                FixResult(
                    finding_id=finding.id,
                    file_path=finding.file_path,
                    description=finding.description,
                    branch=branch_name,
                    applied=False,
                    reason="Dry run -- no changes applied",
                )
            )
            continue

        try:
            if create_branch:
                await _run_git(
                    target_dir, "checkout", "-b", branch_name, base_branch
                )

            # Write fix description file
            fix_dir = os.path.join(target_dir, ".redteam-fixes")
            os.makedirs(fix_dir, exist_ok=True)

            fix_file_path = os.path.join(fix_dir, f"{finding.id}.md")
            fix_content = _generate_fix_description(finding, mitigation)
            with open(fix_file_path, "w", encoding="utf-8") as f:
                f.write(fix_content)

            if create_branch:
                await _run_git(target_dir, "add", fix_file_path)
                commit_msg = (
                    f"fix: {finding.severity} -- {finding.description[:60]}\n\n"
                    f"Automatic fix proposal by RedTeam Arena.\n"
                    f"Finding: {finding.id}\n"
                    f"File: {finding.file_path}:{finding.line_reference}\n"
                    f"Confidence: {mitigation.confidence}\n\n"
                    f"Proposed fix:\n{mitigation.proposed_fix[:200]}"
                )
                await _run_git(target_dir, "commit", "-m", commit_msg)
                await _run_git(target_dir, "checkout", base_branch)

            fixes.append(
                FixResult(
                    finding_id=finding.id,
                    file_path=finding.file_path,
                    description=finding.description,
                    branch=branch_name if create_branch else "",
                    applied=True,
                )
            )
        except Exception as exc:
            # Ensure we return to base branch
            try:
                await _run_git(target_dir, "checkout", base_branch)
            except Exception:
                pass

            fixes.append(
                FixResult(
                    finding_id=finding.id,
                    file_path=finding.file_path,
                    description=finding.description,
                    applied=False,
                    reason=str(exc),
                )
            )

    return Ok(
        value=AutoFixSummary(
            total_findings=len(all_findings),
            fixable_findings=len(fixable_pairs),
            applied_fixes=sum(1 for f in fixes if f.applied),
            skipped_fixes=sum(1 for f in fixes if not f.applied),
            fixes=fixes,
        )
    )


def format_auto_fix_summary(summary: AutoFixSummary) -> str:
    """Format auto-fix summary for terminal display."""
    lines: list[str] = []
    lines.append("")
    lines.append("  Auto-Fix Summary")
    lines.append("  " + "=" * 40)
    lines.append(f"  Total findings:     {summary.total_findings}")
    lines.append(f"  Fixable (high/med): {summary.fixable_findings}")
    lines.append(f"  Applied:            {summary.applied_fixes}")
    lines.append(f"  Skipped:            {summary.skipped_fixes}")
    lines.append("")

    for fix in summary.fixes:
        status = "[OK]" if fix.applied else "[SKIP]"
        lines.append(f"  {status} {fix.description[:60]}")
        if fix.branch:
            lines.append(f"        Branch: {fix.branch}")
        if fix.reason:
            lines.append(f"        Reason: {fix.reason}")

    lines.append("")
    lines.append("  Note: Review all fix branches before merging.")
    lines.append("")
    return "\n".join(lines)
